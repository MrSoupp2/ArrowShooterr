<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arrow Shooter</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #0f001f, #2a0050, #4c0099);
            color: #ea00ff;
            margin: 0;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        @keyframes glowing-text {
            0% { text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff, 0 0 15px #00ffff; }
            100% { text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff; }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes fade-in-scale {
            0% { opacity: 0; transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1); }
        }

        @keyframes button-glow {
            0% { box-shadow: 0 0 5px rgba(187, 136, 255, 0.4); }
            50% { box-shadow: 0 0 15px rgba(187, 136, 255, 0.6), 0 0 20px rgba(153, 0, 255, 0.5); }
            100% { box-shadow: 0 0 5px rgba(187, 136, 255, 0.4); }
        }

        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        canvas {
            background-color: #000;
            border: 2px solid #9900ff;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
            image-rendering: pixelated;
            transition: all 0.3s ease-in-out;
            border-radius: 12px;
            box-shadow: 0 0 25px rgba(153, 0, 255, 0.9), 0 0 50px rgba(153, 0, 255, 0.7);
            width: 90vw;
            height: 90vh;
        }
        
        canvas:hover {
            box-shadow: 0 0 40px rgba(153, 0, 255, 1), 0 0 80px rgba(153, 0, 255, 0.8);
        }

        #studio-name {
            font-size: 1.5rem;
            color: #fff;
            text-shadow: 2px 2px 4px #00ffff;
            animation: glowing-text 1.5s ease-in-out infinite alternate;
            position: absolute;
            top: 20px;
        }

        #game-info {
            position: absolute;
            top: 60px;
            left: 20px;
            font-size: 1rem;
            color: #fff;
            text-shadow: 2px 2px 4px #00ffff;
            animation: glowing-text 1.5s ease-in-out infinite alternate;
        }

        #lives-display {
            position: absolute;
            top: 60px;
            right: 20px;
            font-size: 1rem;
            color: #fff;
            text-shadow: 2px 2px 4px #00ffff;
            animation: glowing-text 1.5s ease-in-out infinite alternate;
        }
        
        .game-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 200;
            display: none;
            animation: fade-in-scale 0.5s ease-out forwards;
        }

        #start-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .screen-title {
            font-size: 5rem;
            font-weight: bold;
            background: linear-gradient(to right, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            background-size: 200% auto;
            animation: pulse 2s infinite, rainbow 4s linear infinite;
        }
        
        .screen-text {
            font-size: 1.2rem;
            color: #fff;
            margin-top: 20px;
            line-height: 1.5;
        }
        
        #final-score {
            font-size: 1.5rem;
            margin-top: 10px;
            color: #fff;
        }
        
        #start-buttons {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 101;
        }

        .ctrl-btn {
            background: linear-gradient(to bottom, #bb88ff, #9900ff, #7700cc);
            color: #fff;
            border: 2px solid #bb88ff;
            border-radius: 20px;
            padding: 10px 20px;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 
                0 4px 15px rgba(187, 136, 255, 0.4), 
                0 0 10px rgba(153, 0, 255, 0.5), 
                inset 0 2px 3px rgba(255, 255, 255, 0.8), 
                inset 0 -4px 6px rgba(0, 0, 0, 0.2);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            font-family: 'Press Start 2P', cursive;
            animation: button-glow 2s infinite ease-in-out alternate;
        }
        
        .ctrl-btn:hover {
            background: linear-gradient(to top, #bb88ff, #9900ff, #7700cc);
            box-shadow: 
                0 6px 20px rgba(187, 136, 255, 0.6), 
                0 0 15px rgba(153, 0, 255, 0.7), 
                inset 0 2px 3px rgba(255, 255, 255, 0.9), 
                inset 0 -2px 3px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
            animation-play-state: paused; /* Stop the glow on hover for a cleaner effect */
        }

        .ctrl-btn:active {
            transform: translateY(1px);
            box-shadow: 
                0 2px 5px rgba(187, 136, 255, 0.3), 
                0 0 5px rgba(153, 0, 255, 0.3), 
                inset 0 1px 1px rgba(255, 255, 255, 0.5);
        }
        
        #restart-btn {
            margin-top: 20px;
            background: linear-gradient(to top, #5d00a3, #4b0082);
            color: #fff;
            border: 2px solid #5d00a3;
            box-shadow: 
                0 4px 15px rgba(93, 0, 163, 0.4), 
                0 0 10px rgba(93, 0, 163, 0.5), 
                inset 0 2px 3px rgba(255, 255, 255, 0.8), 
                inset 0 -4px 6px rgba(0, 0, 0, 0.2);
        }
        
        #restart-btn:hover {
            background: linear-gradient(to bottom, #5d00a3, #4b0082);
            box-shadow: 
                0 6px 20px rgba(93, 0, 163, 0.6), 
                0 0 15px rgba(93, 0, 163, 0.7), 
                inset 0 2px 3px rgba(255, 255, 255, 0.9), 
                inset 0 -2px 3px rgba(0, 0, 0, 0.1);
        }
        
        #footer-text {
            position: fixed;
            bottom: 5px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: #fff;
            text-shadow: 1px 1px 2px #00ffff;
            animation: glowing-text 1.5s ease-in-out infinite alternate;
        }
    </style>
</head>
<body>
    <div id="studio-name">Made by Soupp</div>
    <div id="game-info" style="display:none;">Score: <span id="score">0</span></div>
    <div id="lives-display" style="display:none;">Lives: <span id="lives">1</span></div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div id="start-screen" class="game-screen">
        <div class="screen-title">Arrow Shooter</div>
        <div class="screen-text">
            Use `W` or `ArrowUp` to thrust forward.<br>
            Use `S` or `ArrowDown` to thrust backward.<br>
            Use `A` or `ArrowLeft` and `D` or `ArrowRight` to rotate.<br>
            Use `Space` to shoot.<br>
            You only have **1** life!
        </div>
        <div id="start-buttons">
            <button id="start-btn" class="ctrl-btn">Start Game</button>
        </div>
    </div>

    <div id="game-over-screen" class="game-screen">
        <div class="screen-title" style="color:#ff6b6b; text-shadow: 3px 3px 6px #ff4c4c;">GAME OVER</div>
        <div id="final-score"></div>
        <button id="restart-btn" class="ctrl-btn">Restart Game</button>
    </div>

    <div id="controls">
        <button id="rotate-left-btn" class="ctrl-btn">&larr; Rotate</button>
        <button id="thrust-forward-btn" class="ctrl-btn">Thrust &uarr;</button>
        <button id="thrust-backward-btn" class="ctrl-btn">Thrust &darr;</darr></button>
        <button id="rotate-right-btn" class="ctrl-btn">Rotate &rarr;</button>
        <button id="shoot-btn" class="ctrl-btn">Shoot</button>
        <button id="hyperspace-btn" class="ctrl-btn">Hyperspace</button>
    </div>
    <div id="footer-text">Arrow Shooter</div>
    
    <script>
        window.onload = function() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // Game variables
            const SHIP_SIZE = 30;
            const SHIP_THRUST_SPEED = 3; 
            const SHIP_BACKWARD_THRUST_SPEED = -1.5;
            const SHIP_ROTATION_SPEED = 0.005;
            const MONSTER_SPEED = 0.8;
            const MONSTER_SIZE_LARGE = 80;
            const MONSTER_SIZE_MEDIUM = 40;
            const MONSTER_SIZE_SMALL = 20;
            const BULLET_SPEED = 5;
            const BULLET_LIFESPAN = 600; // in milliseconds
            const FPS = 60;
            const MAX_MONSTERS = 10;
            const STARTING_MONSTERS = 3;
            const EXPLOSION_COOLDOWN = 200; // in milliseconds
            const STAR_COUNT = 100;

            let player;
            let monsters = [];
            let bullets = [];
            let explosions = [];
            let stars = [];
            let keys = {};
            let score = 0;
            let lives = 1;
            let gameOver = false;
            let isGameOverSoundPlayed = false;
            let lastBulletTime = 0;
            let lastThrustTime = 0;
            let lastMonsterExplosionTime = 0;
            let lastPlayerExplosionTime = 0;


            // UI elements
            const scoreElement = document.getElementById('score');
            const livesElement = document.getElementById('lives');
            const startScreen = document.getElementById('start-screen');
            const gameOverScreen = document.getElementById('game-over-screen');
            const finalScoreElement = document.getElementById('final-score');
            const startButton = document.getElementById('start-btn');
            const restartButton = document.getElementById('restart-btn');
            const gameInfoElement = document.getElementById('game-info');
            const livesDisplayElement = document.getElementById('lives-display');
            
            // Sound effects
            let shootSynth;
            let explosionSynth;
            let bgSynth;
            let bgLoop;
            let randomSynth;
            let gameOverSynth;
            const randomNotes = ["A2", "D3", "G3", "C4", "E4"];

            function initAudio() {
                // Background music
                bgSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "sine" },
                    envelope: {
                        attack: 0.02,
                        decay: 0.5,
                        sustain: 0.1,
                        release: 0.5
                    }
                }).toDestination();
                const bgNotes = ["C4", "E4", "G4", "C5", "G4", "E4"];
                
                bgLoop = new Tone.Loop(time => {
                    bgSynth.triggerAttackRelease(bgNotes[bgLoop.iterations % bgNotes.length], "4n", time);
                }, "4n");

                // Sound effects
                shootSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "triangle" },
                    envelope: {
                        attack: 0.005,
                        decay: 0.1,
                        sustain: 0,
                        release: 0.1
                    }
                }).toDestination();
                explosionSynth = new Tone.NoiseSynth().toDestination();
                randomSynth = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: {
                        attack: 0.01,
                        decay: 0.2,
                        sustain: 0,
                        release: 0.5
                    }
                }).toDestination();

                // Game Over sound
                gameOverSynth = new Tone.PolySynth(Tone.FMSynth, {
                    harmonicity: 3,
                    modulationIndex: 1,
                    envelope: {
                        attack: 0.1,
                        decay: 0.5,
                        sustain: 0.2,
                        release: 1.5,
                    },
                    modulationEnvelope: {
                        attack: 0.1,
                        decay: 0.2,
                        sustain: 0.1,
                        release: 0.8
                    }
                }).toDestination();
            }

            function playRandomSound() {
                const randomNote = randomNotes[Math.floor(Math.random() * randomNotes.length)];
                randomSynth.triggerAttackRelease(randomNote, "8n");
            }


            // Game Object Classes
            class Player {
                constructor() {
                    this.x = canvas.width / 2;
                    this.y = canvas.height / 2;
                    this.radius = SHIP_SIZE / 2;
                    this.angle = Math.PI / 2;
                    this.velocity = { x: 0, y: 0 };
                    this.isThrustingForward = false;
                    this.isThrustingBackward = false;
                    this.isShooting = false;
                }
                
                // Draws the player ship as a triangle with a thrust effect
                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(-this.angle);

                    // Main ship body with a glossy, crystalline effect
                    ctx.beginPath();
                    ctx.moveTo(this.radius * 1.5, 0);
                    ctx.lineTo(-this.radius, -this.radius * 0.8);
                    ctx.lineTo(-this.radius * 0.5, 0);
                    ctx.lineTo(-this.radius, this.radius * 0.8);
                    ctx.closePath();
                    
                    let gradient = ctx.createLinearGradient(0, -this.radius, 0, this.radius);
                    gradient.addColorStop(0, '#00ffff');
                    gradient.addColorStop(0.5, '#9900ff');
                    gradient.addColorStop(1, '#00e5ff');
                    ctx.fillStyle = gradient;
                    ctx.fill();

                    // Inner highlight for glossy effect
                    ctx.beginPath();
                    ctx.moveTo(this.radius * 1.2, 0);
                    ctx.lineTo(-this.radius * 0.7, -this.radius * 0.6);
                    ctx.lineTo(-this.radius * 0.4, 0);
                    ctx.lineTo(-this.radius * 0.7, this.radius * 0.6);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.fill();
                    
                    // Outer outline
                    ctx.strokeStyle = '#007799';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Draw thruster flames if thrusting forward
                    if (this.isThrustingForward) {
                        ctx.beginPath();
                        ctx.moveTo(-this.radius * 0.5, -this.radius * 0.5);
                        ctx.lineTo(-this.radius * 2, 0);
                        ctx.lineTo(-this.radius * 0.5, this.radius * 0.5);
                        ctx.closePath();
                        ctx.fillStyle = '#00ffff';
                        ctx.fill();
                    }
                    
                    // Draw backward thruster flames
                    if (this.isThrustingBackward) {
                        ctx.beginPath();
                        ctx.moveTo(this.radius, -this.radius * 0.3);
                        ctx.lineTo(this.radius * 2, 0);
                        ctx.lineTo(this.radius, this.radius * 0.3);
                        ctx.closePath();
                        ctx.fillStyle = '#9900ff';
                        ctx.fill();
                    }

                    ctx.restore();
                }
                
                // Updates the player's position and velocity
                update() {
                    // Reset velocity on each frame for direct control
                    this.velocity.x = 0;
                    this.velocity.y = 0;

                    if (this.isThrustingForward) {
                        this.velocity.x = SHIP_THRUST_SPEED * Math.cos(this.angle);
                        this.velocity.y = SHIP_THRUST_SPEED * Math.sin(this.angle);
                    }
                    
                    if (this.isThrustingBackward) {
                        this.velocity.x = SHIP_BACKWARD_THRUST_SPEED * Math.cos(this.angle);
                        this.velocity.y = SHIP_BACKWARD_THRUST_SPEED * Math.sin(this.angle);
                    }
                    
                    this.x += this.velocity.x;
                    this.y += this.velocity.y;
                    
                    // Screen wrapping
                    if (this.x < 0) this.x = canvas.width;
                    if (this.x > canvas.width) this.x = 0;
                    if (this.y < 0) this.y = canvas.height;
                    if (this.y > canvas.height) this.y = 0;
                }

                // Teleports the player to a new random location
                hyperspace() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.velocity = { x: 0, y: 0 };
                }
            }
            
            class Monster {
                constructor(x, y, size) {
                    this.x = x;
                    this.y = y;
                    this.size = size;
                    this.radius = size / 2;
                    this.velocity = {
                        x: Math.random() * MONSTER_SPEED * (Math.random() > 0.5 ? 1 : -1),
                        y: Math.random() * MONSTER_SPEED * (Math.random() > 0.5 ? 1 : -1)
                    };
                }
                
                // Draws the monster as a glowing crystal
                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);

                    // Base shape for depth
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#1a0033';
                    ctx.fill();
                    ctx.strokeStyle = '#9900ff';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Glowing inner core
                    let radialGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
                    radialGradient.addColorStop(0, 'rgba(153, 0, 255, 0.8)');
                    radialGradient.addColorStop(0.5, 'rgba(153, 0, 255, 0.4)');
                    radialGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = radialGradient;
                    ctx.fill();

                    // Eyes
                    const eyeSize = this.radius * 0.2;
                    ctx.beginPath();
                    ctx.arc(-this.radius * 0.3, -this.radius * 0.3, eyeSize, 0, Math.PI * 2);
                    ctx.arc(this.radius * 0.3, -this.radius * 0.3, eyeSize, 0, Math.PI * 2);
                    ctx.fillStyle = '#00ffff';
                    ctx.fill();

                    ctx.restore();
                }
                
                // Updates the monster's position
                update() {
                    this.x += this.velocity.x;
                    this.y += this.velocity.y;
                    
                    // Screen wrapping
                    if (this.x + this.radius < 0) this.x = canvas.width + this.radius;
                    if (this.x - this.radius > canvas.width) this.x = -this.radius;
                    if (this.y + this.radius < 0) this.y = canvas.height + this.radius;
                    if (this.y - this.radius > canvas.height) this.y = -this.radius;
                }
            }

            class Bullet {
                constructor(x, y, angle) {
                    this.x = x;
                    this.y = y;
                    this.velocity = {
                        x: BULLET_SPEED * Math.cos(angle),
                        y: BULLET_SPEED * Math.sin(angle)
                    };
                    this.radius = 2;
                    this.spawnTime = Date.now();
                }
                
                // Draws the bullet
                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#00ffff';
                    ctx.fill();
                }
                
                // Updates the bullet's position
                update() {
                    this.x += this.velocity.x;
                    this.y += this.velocity.y;
                }
            }

            class Explosion {
                constructor(x, y, color) {
                    this.particles = [];
                    for (let i = 0; i < 20; i++) {
                        this.particles.push({
                            x: x,
                            y: y,
                            vx: (Math.random() - 0.5) * 5,
                            vy: (Math.random() - 0.5) * 5,
                            life: 60,
                            color: color
                        });
                    }
                }
                
                draw() {
                    this.particles.forEach(p => {
                        ctx.fillStyle = `rgba(${parseInt(p.color.slice(1,3), 16)}, ${parseInt(p.color.slice(3,5), 16)}, ${parseInt(p.color.slice(5,7), 16)}, ${p.life / 60})`;
                        ctx.fillRect(p.x, p.y, 2, 2);
                    });
                }

                update() {
                    this.particles.forEach(p => {
                        p.x += p.vx;
                        p.y += p.vy;
                        p.life--;
                    });
                    this.particles = this.particles.filter(p => p.life > 0);
                }
            }

            class Star {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.radius = Math.random() * 1.5;
                    this.alpha = Math.random();
                    this.alphaSpeed = Math.random() * 0.01 + 0.005;
                    this.dir = 1;
                }
                
                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
                    ctx.fill();
                }

                update() {
                    this.alpha += this.dir * this.alphaSpeed;
                    if (this.alpha > 1 || this.alpha < 0) {
                        this.dir *= -1;
                    }
                }
            }
            
            // Set up canvas dimensions to be responsive
            const setCanvasSize = () => {
                canvas.width = window.innerWidth * 0.9;
                canvas.height = window.innerHeight * 0.9;

                // Re-initialize stars to fit new canvas size
                stars = [];
                for(let i = 0; i < STAR_COUNT; i++) {
                    stars.push(new Star());
                }
            };
            
            // Initial call to set canvas size
            setCanvasSize();
            
            window.addEventListener('resize', setCanvasSize);

            // Main game loop
            function gameLoop() {
                if (gameOver) {
                    bgLoop.stop();
                    gameOverScreen.style.display = 'flex';
                    finalScoreElement.textContent = `Final Score: ${score}`;
                    
                    if (!isGameOverSoundPlayed) {
                        try {
                            gameOverSynth.triggerAttackRelease(["C2", "G#1"], "2n");
                            isGameOverSoundPlayed = true;
                        } catch (e) {
                            console.error("Error playing game over sound:", e);
                        }
                    }
                    return;
                }
                
                // Clear the canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Update and draw stars
                stars.forEach(star => {
                    star.update();
                    star.draw();
                });
                
                // Update and draw player
                player.update();
                player.draw();
                
                // Update and draw monsters
                monsters.forEach(monster => {
                    monster.update();
                    monster.draw();
                });
                
                // Update and draw bullets
                for (let i = bullets.length - 1; i >= 0; i--) {
                    bullets[i].update();
                    bullets[i].draw();
                    if (Date.now() - bullets[i].spawnTime > BULLET_LIFESPAN) {
                        bullets.splice(i, 1);
                    }
                }

                // Update and draw explosions
                for (let i = explosions.length - 1; i >= 0; i--) {
                    explosions[i].update();
                    explosions[i].draw();
                    if (explosions[i].particles.length === 0) {
                        explosions.splice(i, 1);
                    }
                }

                // Handle player input
                if (keys['ArrowUp'] || keys['w'] || keys['thrust-forward']) {
                    player.isThrustingForward = true;
                } else {
                    player.isThrustingForward = false;
                }
                
                if (keys['ArrowDown'] || keys['s'] || keys['thrust-backward']) {
                    player.isThrustingBackward = true;
                } else {
                    player.isThrustingBackward = false;
                }

                if (keys['ArrowLeft'] || keys['a'] || keys['rotate-left']) {
                    player.angle -= SHIP_ROTATION_SPEED;
                }
                if (keys['ArrowRight'] || keys['d'] || keys['rotate-right']) {
                    player.angle += SHIP_ROTATION_SPEED;
                }
                if (keys[' ']) {
                    if (Date.now() - lastBulletTime > BULLET_LIFESPAN) {
                        // Calculate new bullet start position in front of the ship
                        const bulletX = player.x + (player.radius * 1.5 * Math.cos(player.angle));
                        const bulletY = player.y + (player.radius * 1.5 * Math.sin(player.angle));
                        bullets.push(new Bullet(bulletX, bulletY, player.angle));
                        try {
                            shootSynth.triggerAttackRelease("A4", "8n");
                        } catch (e) {
                            console.error("Error playing shoot sound:", e);
                        }
                        lastBulletTime = Date.now();
                    }
                }
                
                // Collision detection
                checkCollisions();

                if (monsters.length === 0) {
                    generateMonsters(STARTING_MONSTERS + Math.floor(score / 500));
                }

                requestAnimationFrame(gameLoop);
            }
            
            // Check for collisions between all objects
            function checkCollisions() {
                // Bullet-monster collisions
                for (let i = bullets.length - 1; i >= 0; i--) {
                    for (let j = monsters.length - 1; j >= 0; j--) {
                        const dist = Math.sqrt(Math.pow(bullets[i].x - monsters[j].x, 2) + Math.pow(bullets[i].y - monsters[j].y, 2));
                        if (dist < monsters[j].radius) {
                            // Collision detected
                            explosions.push(new Explosion(monsters[j].x, monsters[j].y, '#00ffff')); // Aqua explosion for monsters
                            if (Date.now() - lastMonsterExplosionTime > EXPLOSION_COOLDOWN) {
                                try {
                                    explosionSynth.triggerAttackRelease("16n");
                                    lastMonsterExplosionTime = Date.now();
                                    playRandomSound(); // Play random sound on monster destruction
                                } catch (e) {
                                    console.error("Error playing monster explosion sound:", e);
                                }
                            }
                            score += Math.floor(100 / (monsters[j].size / 10)); // Scoring based on size
                            scoreElement.textContent = score;

                            // Split the monster
                            if (monsters[j].size > MONSTER_SIZE_SMALL) {
                                const newSize = monsters[j].size === MONSTER_SIZE_LARGE ? MONSTER_SIZE_MEDIUM : MONSTER_SIZE_SMALL;
                                monsters.push(new Monster(monsters[j].x, monsters[j].y, newSize));
                                monsters.push(new Monster(monsters[j].x, monsters[j].y, newSize));
                            }
                            
                            // Remove bullet and monster
                            bullets.splice(i, 1);
                            monsters.splice(j, 1);
                            break; // Exit inner loop as bullet is gone
                        }
                    }
                }
                
                // Player-monster collisions
                for (let i = monsters.length - 1; i >= 0; i--) {
                    const dist = Math.sqrt(Math.pow(player.x - monsters[i].x, 2) + Math.pow(player.y - monsters[i].y, 2));
                    if (dist < player.radius + monsters[i].radius) {
                        lives--;
                        livesElement.textContent = lives;
                        explosions.push(new Explosion(player.x, player.y, '#9900ff')); // Purple explosion for player
                        if (Date.now() - lastPlayerExplosionTime > EXPLOSION_COOLDOWN) {
                            try {
                                explosionSynth.triggerAttackRelease("4n");
                                lastPlayerExplosionTime = Date.now();
                            } catch (e) {
                                console.error("Error playing player explosion sound:", e);
                            }
                        }
                        if (lives <= 0) {
                            gameOver = true;
                        } else {
                            player = new Player(); // Reset player position
                        }
                    }
                }
            }

            // Generate a random number of monsters
            function generateMonsters(count) {
                for (let i = 0; i < count; i++) {
                    let x, y;
                    // Spawn monsters away from the player
                    do {
                        x = Math.random() * canvas.width;
                        y = Math.random() * canvas.height;
                    } while (Math.sqrt(Math.pow(x - player.x, 2) + Math.pow(y - player.y, 2)) < 200);
                    monsters.push(new Monster(x, y, MONSTER_SIZE_LARGE));
                }
            }

            // Game Initialization
            function init() {
                player = new Player();
                monsters = [];
                bullets = [];
                explosions = [];
                keys = {};
                score = 0;
                lives = 1;
                gameOver = false;
                isGameOverSoundPlayed = false;
                lastBulletTime = 0;
                lastMonsterExplosionTime = 0;
                lastPlayerExplosionTime = 0;
                scoreElement.textContent = score;
                livesElement.textContent = lives;
                gameOverScreen.style.display = 'none';
                
                generateMonsters(STARTING_MONSTERS);
            }

            // Event Listeners for Keyboard Controls
            document.addEventListener('keydown', (e) => {
                keys[e.key] = true;
            });
            document.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });

            // Event Listeners for Touch Controls
            document.getElementById('rotate-left-btn').addEventListener('touchstart', (e) => { e.preventDefault(); keys['rotate-left'] = true; });
            document.getElementById('rotate-left-btn').addEventListener('touchend', (e) => { e.preventDefault(); keys['rotate-left'] = false; });
            document.getElementById('rotate-left-btn').addEventListener('mousedown', (e) => { keys['rotate-left'] = true; });
            document.getElementById('rotate-left-btn').addEventListener('mouseup', (e) => { keys['rotate-left'] = false; });
            
            document.getElementById('thrust-forward-btn').addEventListener('touchstart', (e) => { e.preventDefault(); keys['thrust-forward'] = true; });
            document.getElementById('thrust-forward-btn').addEventListener('touchend', (e) => { e.preventDefault(); keys['thrust-forward'] = false; });
            document.getElementById('thrust-forward-btn').addEventListener('mousedown', (e) => { keys['thrust-forward'] = true; });
            document.getElementById('thrust-forward-btn').addEventListener('mouseup', (e) => { keys['thrust-forward'] = false; });
            
            document.getElementById('thrust-backward-btn').addEventListener('touchstart', (e) => { e.preventDefault(); keys['thrust-backward'] = true; });
            document.getElementById('thrust-backward-btn').addEventListener('touchend', (e) => { e.preventDefault(); keys['thrust-backward'] = false; });
            document.getElementById('thrust-backward-btn').addEventListener('mousedown', (e) => { keys['thrust-backward'] = true; });
            document.getElementById('thrust-backward-btn').addEventListener('mouseup', (e) => { keys['thrust-backward'] = false; });
            
            document.getElementById('rotate-right-btn').addEventListener('touchstart', (e) => { e.preventDefault(); keys['rotate-right'] = true; });
            document.getElementById('rotate-right-btn').addEventListener('touchend', (e) => { e.preventDefault(); keys['rotate-right'] = false; });
            document.getElementById('rotate-right-btn').addEventListener('mousedown', (e) => { keys['rotate-right'] = true; });
            document.getElementById('rotate-right-btn').addEventListener('mouseup', (e) => { keys['rotate-right'] = false; });

            document.getElementById('shoot-btn').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                if (Date.now() - lastBulletTime > BULLET_LIFESPAN) {
                    const bulletX = player.x + (player.radius * 1.5 * Math.cos(player.angle));
                    const bulletY = player.y + (player.radius * 1.5 * Math.sin(player.angle));
                    bullets.push(new Bullet(bulletX, bulletY, player.angle));
                    try {
                        shootSynth.triggerAttackRelease("A4", "8n");
                    } catch (e) {
                        console.error("Error playing shoot sound:", e);
                    }
                    lastBulletTime = Date.now();
                }
            });
            document.getElementById('shoot-btn').addEventListener('mousedown', (e) => { 
                if (Date.now() - lastBulletTime > BULLET_LIFESPAN) {
                    const bulletX = player.x + (player.radius * 1.5 * Math.cos(player.angle));
                    const bulletY = player.y + (player.radius * 1.5 * Math.sin(player.angle));
                    bullets.push(new Bullet(bulletX, bulletY, player.angle));
                    try {
                        shootSynth.triggerAttackRelease("A4", "8n");
                    } catch (e) {
                        console.error("Error playing shoot sound:", e);
                    }
                    lastBulletTime = Date.now();
                }
            });

            document.getElementById('hyperspace-btn').addEventListener('click', () => {
                player.hyperspace();
                // Check for collision after hyperspace jump
                for (let i = 0; i < monsters.length; i++) {
                    const dist = Math.sqrt(Math.pow(player.x - monsters[i].x, 2) + Math.pow(player.y - monsters[i].y, 2));
                    if (dist < player.radius + monsters[i].radius) {
                        lives--;
                        livesElement.textContent = lives;
                        explosions.push(new Explosion(player.x, player.y, '#9900ff'));
                        if (Date.now() - lastPlayerExplosionTime > EXPLOSION_COOLDOWN) {
                            try {
                                explosionSynth.triggerAttackRelease("4n");
                                lastPlayerExplosionTime = Date.now();
                            } catch (e) {
                                console.error("Error playing player explosion sound:", e);
                            }
                        }
                        if (lives <= 0) {
                            gameOver = true;
                        }
                        break;
                    }
                }
            });

            startButton.addEventListener('click', () => {
                startGame();
            });

            restartButton.addEventListener('click', () => {
                startGame();
            });
            
            function startGame() {
                try {
                    Tone.start();
                    console.log("Tone.js started successfully!");
                    bgLoop.start(0);
                    console.log("Background music loop started.");
                } catch (e) {
                    console.error("Error starting Tone.js:", e);
                }

                startScreen.style.display = 'none';
                gameOverScreen.style.display = 'none';
                gameInfoElement.style.display = 'block';
                livesDisplayElement.style.display = 'block';
                init();
                gameLoop();
            }

            // Initial setup for the background stars
            for(let i = 0; i < STAR_COUNT; i++) {
                stars.push(new Star());
            }
            initAudio();

            // Initial game loop to show stars on start screen
            function initialLoop() {
                if (startScreen.style.display === 'flex' || gameOverScreen.style.display === 'flex') {
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    stars.forEach(star => {
                        star.update();
                        star.draw();
                    });
                    requestAnimationFrame(initialLoop);
                }
            }
            initialLoop();
        };
    </script>
</body>
</html>
 